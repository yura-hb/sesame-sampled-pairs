import org.eclipse.jdt.internal.core.util.CharArrayBuffer;

abstract class DOMNode implements IDOMNode {
    /**
    * Appends the contents of all children of this node to the
    * given &lt;code&gt;CharArrayBuffer&lt;/code&gt;.
    *
    * &lt;p&gt;This algorithm used minimizes String generation by merging
    * adjacent unfragmented children into one substring operation.
    *
    */
    protected void appendContentsOfChildren(CharArrayBuffer buffer) {
	DOMNode child = this.fFirstChild;
	DOMNode sibling;

	int start = 0, end = 0;
	if (child != null) {
	    start = child.getStartPosition();
	    end = child.getEndPosition();
	}
	while (child != null) {
	    sibling = child.fNextNode;
	    if (sibling != null) {
		if (sibling.isContentMergableWith(child)) {
		    end = sibling.getEndPosition();
		} else {
		    if (child.isFragmented()) {
			child.appendContents(buffer);
		    } else {
			buffer.append(child.getDocument(), start, end + 1 - start);
		    }
		    start = sibling.getStartPosition();
		    end = sibling.getEndPosition();
		}
	    } else {
		if (child.isFragmented()) {
		    child.appendContents(buffer);
		} else {
		    buffer.append(child.getDocument(), start, end + 1 - start);
		}
	    }
	    child = sibling;
	}
    }

    /**
     * The first child of this node - &lt;code&gt;null&lt;/code&gt;
     * when this node has no children. (Children of a node
     * are implemented as a doubly linked list).
     */
    protected DOMNode fFirstChild = null;
    /**
     * The sibling node following this node - &lt;code&gt;null&lt;/code&gt;
     * for the last node in the sibling list.
     */
    protected DOMNode fNextNode = null;
    /**
     * The original entire inclusive range of this node's contents
     * within its document. Values of -1 indicate the contents
     * of this node do not exist in the document.
     */
    protected int[] fSourceRange;
    /**
     * True when this node has attributes that have
     * been altered from their original state in the
     * shared document, or when the attributes of a
     * descendant have been altered. False when the
     * contents of this node and all descendants are
     * consistent with the content of the shared
     * document.
     */
    protected boolean fIsFragmented = false;
    /**
     * The shared document that the contents for this node
     * are contained in. Attribute indicies are positions
     * in this character array.
     */
    protected char[] fDocument = null;

    /**
    * Returns the original position of the first character of this
    * node's contents in its document.
    */
    public int getStartPosition() {
	return this.fSourceRange[0];
    }

    /**
    * Returns the original position of the last character of this
    * node's contents in its document.
    */
    public int getEndPosition() {
	return this.fSourceRange[1];
    }

    /**
    * Returns &lt;code&gt;true&lt;/code&gt; if the contents of this node are from the same document as
    * the given node, the contents of this node immediately follow the contents
    * of the given node, and neither this node or the given node are fragmented -
    * otherwise &lt;code&gt;false&lt;/code&gt;.
    */
    protected boolean isContentMergableWith(DOMNode node) {
	return !node.isFragmented() && !isFragmented() && node.getDocument() == getDocument()
		&& node.getEndPosition() + 1 == getStartPosition();
    }

    /**
    * Returns &lt;code&gt;true&lt;/code&gt; if this node's or a descendant node's contents
    * have been altered since this node was created. This indicates
    * that the contents of this node are no longer consistent with
    * the contents of this node's document.
    */
    protected boolean isFragmented() {
	return this.fIsFragmented;
    }

    /**
    * Appends the current contents of this document fragment
    * to the given &lt;code&gt;CharArrayBuffer&lt;/code&gt;.
    *
    * &lt;p&gt;If this node is fragmented, contents must be generated by
    * using the original document and indicies as a form for the current
    * attribute values of this node. If this node not fragmented, the
    * contents can be obtained from the document.
    *
    */
    protected void appendContents(CharArrayBuffer buffer) {
	if (isFragmented()) {
	    appendFragmentedContents(buffer);
	} else {
	    buffer.append(this.fDocument, this.fSourceRange[0], this.fSourceRange[1] + 1 - this.fSourceRange[0]);
	}
    }

    /**
    * Returns the document containing this node's original contents.
    * The document may be shared by other nodes.
    */
    protected char[] getDocument() {
	return this.fDocument;
    }

    /**
    * Appends the contents of this node to the given &lt;code&gt;CharArrayBufer&lt;/code&gt;, using
    * the original document and indicies as a form for the current attribute
    * values of this node.
    */
    protected abstract void appendFragmentedContents(CharArrayBuffer buffer);

}

