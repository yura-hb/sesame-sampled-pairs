import jdk.internal.org.objectweb.asm.MethodVisitor;
import jdk.nashorn.internal.codegen.types.Type;
import jdk.nashorn.internal.runtime.Context;
import jdk.nashorn.internal.runtime.logging.DebugLogger;

class MethodEmitter {
    /**
     * Abstraction for performing a conditional jump of any type
     *
     * @see Condition
     *
     * @param cond      the condition to test
     * @param trueLabel the destination label is condition is true
     */
    void conditionalJump(final Condition cond, final Label trueLabel) {
	conditionalJump(cond, cond != Condition.GT && cond != Condition.GE, trueLabel);
    }

    /** The ASM MethodVisitor we are plugged into */
    private final MethodVisitor method;
    /** Current type stack for current evaluation */
    private Label.Stack stack;
    private final boolean debug;
    private static int linePrefix = 0;
    /** The context */
    private final Context context;
    /** Debug flag, should we dump all generated bytecode along with stacks? */
    private final DebugLogger log;
    /** dump stack on a particular line, or -1 if disabled */
    private static final int DEBUG_TRACE_LINE;

    /**
     * Abstraction for performing a conditional jump of any type,
     * including a dcmpg/dcmpl semantic for doubles.
     *
     * @param cond      the condition to test
     * @param isCmpG    is this a dcmpg for numbers, false if it's a dcmpl
     * @param trueLabel the destination label if condition is true
     */
    void conditionalJump(final Condition cond, final boolean isCmpG, final Label trueLabel) {
	if (peekType().isCategory2()) {
	    debug("[ld]cmp isCmpG=", isCmpG);
	    pushType(get2n().cmp(method, isCmpG));
	    jump(Condition.toUnary(cond), trueLabel, 1);
	} else {
	    debug("if", cond);
	    jump(Condition.toBinary(cond, peekType().isObject()), trueLabel, 2);
	}
    }

    /**
     * Peek at the type at the top of the stack
     *
     * @return the type at the top of the stack
     */
    final Type peekType() {
	return stack.peek();
    }

    private void debug(final Object arg0, final Object arg1) {
	if (debug) {
	    debug(30, new Object[] { arg0, arg1 });
	}
    }

    /**
     * Helper function - expect two types that are numbers and equivalent
     *
     * @return common type
     */
    private NumericType get2n() {
	final NumericType p0 = popNumeric();
	final NumericType p1 = popNumeric();
	assert p0.isEquivalentTo(p1) : "expecting equivalent types on stack but got " + p0 + " and " + p1;
	return p0;
    }

    /**
     * Push a type to the existing stack
     * @param type the type
     */
    void pushType(final Type type) {
	if (type != null) {
	    stack.push(type);
	}
    }

    /**
     * Helper function for jumps, conditional or not
     * @param opcode  opcode for jump
     * @param label   destination
     * @param n       elements on stack to compare, 0-2
     */
    private void jump(final int opcode, final Label label, final int n) {
	for (int i = 0; i &lt; n; i++) {
	    assert peekType().isInteger() || peekType().isBoolean()
		    || peekType().isObject() : "expecting integer type or object for jump, but found " + peekType();
	    popType();
	}
	joinTo(label);
	method.visitJumpInsn(opcode, label.getLabel());
    }

    private void debug(final int padConstant, final Object... args) {
	if (debug) {
	    final StringBuilder sb = new StringBuilder();
	    int pad;

	    sb.append('#');
	    sb.append(++linePrefix);

	    pad = 5 - sb.length();
	    while (pad &gt; 0) {
		sb.append(' ');
		pad--;
	    }

	    if (isReachable() && !stack.isEmpty()) {
		sb.append("{");
		sb.append(stack.size());
		sb.append(":");
		for (int pos = 0; pos &lt; stack.size(); pos++) {
		    final Type t = stack.peek(pos);

		    if (t == Type.SCOPE) {
			sb.append("scope");
		    } else if (t == Type.THIS) {
			sb.append("this");
		    } else if (t.isObject()) {
			String desc = t.getDescriptor();
			int i;
			for (i = 0; desc.charAt(i) == '[' && i &lt; desc.length(); i++) {
			    sb.append('[');
			}
			desc = desc.substring(i);
			final int slash = desc.lastIndexOf('/');
			if (slash != -1) {
			    desc = desc.substring(slash + 1, desc.length() - 1);
			}
			if ("Object".equals(desc)) {
			    sb.append('O');
			} else {
			    sb.append(desc);
			}
		    } else {
			sb.append(t.getDescriptor());
		    }
		    final int loadIndex = stack.localLoads[stack.sp - 1 - pos];
		    if (loadIndex != Label.Stack.NON_LOAD) {
			sb.append('(').append(loadIndex).append(')');
		    }
		    if (pos + 1 &lt; stack.size()) {
			sb.append(' ');
		    }
		}
		sb.append('}');
		sb.append(' ');
	    }

	    pad = padConstant - sb.length();
	    while (pad &gt; 0) {
		sb.append(' ');
		pad--;
	    }

	    for (final Object arg : args) {
		sb.append(arg);
		sb.append(' ');
	    }

	    if (context.getEnv() != null) { //early bootstrap code doesn't have inited context yet
		log.info(sb);
		if (DEBUG_TRACE_LINE == linePrefix) {
		    new Throwable().printStackTrace(log.getOutputStream());
		}
	    }
	}
    }

    /**
     * Pop a type from the existing stack, ensuring that it is numeric. Boolean type is popped as int type.
     *
     * @return the type
     */
    private NumericType popNumeric() {
	final Type type = popType();
	if (type.isBoolean()) {
	    // Booleans are treated as int for purposes of arithmetic operations
	    return Type.INT;
	}
	assert type.isNumeric();
	return (NumericType) type;
    }

    /**
     * Pop a type from the existing stack, no matter what it is.
     *
     * @return the type
     */
    private Type popType() {
	return stack.pop();
    }

    /**
     * A join in control flow - helper function that makes sure all entry stacks
     * discovered for the join point so far are equivalent
     *
     * MergeStack: we are about to enter a label. If its stack, label.getStack() is null
     * we have never been here before. Then we are expected to carry a stack with us.
     *
     * @param label label
     */
    private void joinTo(final Label label) {
	assert isReachable();
	label.joinFrom(stack);
    }

    boolean isReachable() {
	return stack != null;
    }

}

