import static com.google.common.collect.RegularImmutableList.EMPTY;
import java.util.Arrays;
import java.util.Iterator;

abstract class ImmutableList&lt;E&gt; extends ImmutableCollection&lt;E&gt; implements List&lt;E&gt;, RandomAccess {
    /**
    * Returns an immutable list containing the given elements, in order.
    *
    * @throws NullPointerException if any of {@code elements} is null
    */
    public static &lt;E&gt; ImmutableList&lt;E&gt; copyOf(Iterator&lt;? extends E&gt; elements) {
	// We special-case for 0 or 1 elements, but going further is madness.
	if (!elements.hasNext()) {
	    return of();
	}
	E first = elements.next();
	if (!elements.hasNext()) {
	    return of(first);
	} else {
	    return new ImmutableList.Builder&lt;E&gt;().add(first).addAll(elements).build();
	}
    }

    /**
    * Returns the empty immutable list. This list behaves and performs comparably to {@link
    * Collections#emptyList}, and is preferable mainly for consistency and maintainability of your
    * code.
    */
    // Casting to any type is safe because the list will never hold any elements.
    @SuppressWarnings("unchecked")
    public static &lt;E&gt; ImmutableList&lt;E&gt; of() {
	return (ImmutableList&lt;E&gt;) EMPTY;
    }

    /**
    * Returns an immutable list containing a single element. This list behaves and performs
    * comparably to {@link Collections#singleton}, but will not accept a null element. It is
    * preferable mainly for consistency and maintainability of your code.
    *
    * @throws NullPointerException if {@code element} is null
    */
    public static &lt;E&gt; ImmutableList&lt;E&gt; of(E element) {
	return new SingletonImmutableList&lt;E&gt;(element);
    }

    /**
    * Views the array as an immutable list. Copies if the specified range does not cover the complete
    * array. Does not check for nulls.
    */
    static &lt;E&gt; ImmutableList&lt;E&gt; asImmutableList(Object[] elements, int length) {
	switch (length) {
	case 0:
	    return of();
	case 1:
	    return of((E) elements[0]);
	default:
	    if (length &lt; elements.length) {
		elements = Arrays.copyOf(elements, length);
	    }
	    return new RegularImmutableList&lt;E&gt;(elements);
	}
    }

    class Builder&lt;E&gt; extends Builder&lt;E&gt; {
	/**
	* Creates a new builder. The returned builder is equivalent to the builder generated by {@link
	* ImmutableList#builder}.
	*/
	public Builder() {
	    this(DEFAULT_INITIAL_CAPACITY);
	}

	/**
	* Adds {@code element} to the {@code ImmutableList}.
	*
	* @param element the element to add
	* @return this {@code Builder} object
	* @throws NullPointerException if {@code element} is null
	*/
	@CanIgnoreReturnValue
	@Override
	public Builder&lt;E&gt; add(E element) {
	    checkNotNull(element);
	    getReadyToExpandTo(size + 1);
	    contents[size++] = element;
	    return this;
	}

	/**
	* Adds each element of {@code elements} to the {@code ImmutableList}.
	*
	* @param elements the {@code Iterable} to add to the {@code ImmutableList}
	* @return this {@code Builder} object
	* @throws NullPointerException if {@code elements} is null or contains a null element
	*/
	@CanIgnoreReturnValue
	@Override
	public Builder&lt;E&gt; addAll(Iterator&lt;? extends E&gt; elements) {
	    super.addAll(elements);
	    return this;
	}

	/**
	* Returns a newly-created {@code ImmutableList} based on the contents of the {@code Builder}.
	*/
	@Override
	public ImmutableList&lt;E&gt; build() {
	    forceCopy = true;
	    return asImmutableList(contents, size);
	}

	Builder(int capacity) {
	    this.contents = new Object[capacity];
	    this.size = 0;
	}

	private void getReadyToExpandTo(int minCapacity) {
	    if (contents.length &lt; minCapacity) {
		this.contents = Arrays.copyOf(contents, expandedCapacity(contents.length, minCapacity));
		forceCopy = false;
	    } else if (forceCopy) {
		contents = Arrays.copyOf(contents, contents.length);
		forceCopy = false;
	    }
	}

    }

}

