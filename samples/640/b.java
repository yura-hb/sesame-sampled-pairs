import java.util.Collection;
import java.util.Map;
import java.util.Map.Entry;

class ImmutableSetMultimap&lt;K, V&gt; extends ImmutableMultimap&lt;K, V&gt; implements SetMultimap&lt;K, V&gt; {
    /**
    * Returns an immutable multimap containing the given entries, in order. Repeated occurrences of
    * an entry (according to {@link Object#equals}) after the first are ignored.
    */
    public static &lt;K, V&gt; ImmutableSetMultimap&lt;K, V&gt; of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4) {
	ImmutableSetMultimap.Builder&lt;K, V&gt; builder = ImmutableSetMultimap.builder();
	builder.put(k1, v1);
	builder.put(k2, v2);
	builder.put(k3, v3);
	builder.put(k4, v4);
	return builder.build();
    }

    /**
    * Returned by get() when a missing key is provided. Also holds the comparator, if any, used for
    * values.
    */
    private final transient ImmutableSet&lt;V&gt; emptySet;

    /** Returns a new {@link Builder}. */
    public static &lt;K, V&gt; Builder&lt;K, V&gt; builder() {
	return new Builder&lt;&gt;();
    }

    /** Creates an ImmutableSetMultimap from an asMap.entrySet. */
    static &lt;K, V&gt; ImmutableSetMultimap&lt;K, V&gt; fromMapEntries(
	    Collection&lt;? extends Map.Entry&lt;? extends K, ? extends Collection&lt;? extends V&gt;&gt;&gt; mapEntries,
	    @Nullable Comparator&lt;? super V&gt; valueComparator) {
	if (mapEntries.isEmpty()) {
	    return of();
	}
	ImmutableMap.Builder&lt;K, ImmutableSet&lt;V&gt;&gt; builder = new ImmutableMap.Builder&lt;&gt;(mapEntries.size());
	int size = 0;

	for (Entry&lt;? extends K, ? extends Collection&lt;? extends V&gt;&gt; entry : mapEntries) {
	    K key = entry.getKey();
	    Collection&lt;? extends V&gt; values = entry.getValue();
	    ImmutableSet&lt;V&gt; set = valueSet(valueComparator, values);
	    if (!set.isEmpty()) {
		builder.put(key, set);
		size += set.size();
	    }
	}

	return new ImmutableSetMultimap&lt;&gt;(builder.build(), size, valueComparator);
    }

    /** Returns the empty multimap. */
    // Casting is safe because the multimap will never hold any elements.
    @SuppressWarnings("unchecked")
    public static &lt;K, V&gt; ImmutableSetMultimap&lt;K, V&gt; of() {
	return (ImmutableSetMultimap&lt;K, V&gt;) EmptyImmutableSetMultimap.INSTANCE;
    }

    private static &lt;V&gt; ImmutableSet&lt;V&gt; valueSet(@Nullable Comparator&lt;? super V&gt; valueComparator,
	    Collection&lt;? extends V&gt; values) {
	return (valueComparator == null) ? ImmutableSet.copyOf(values)
		: ImmutableSortedSet.copyOf(valueComparator, values);
    }

    ImmutableSetMultimap(ImmutableMap&lt;K, ImmutableSet&lt;V&gt;&gt; map, int size,
	    @Nullable Comparator&lt;? super V&gt; valueComparator) {
	super(map, size);
	this.emptySet = emptySet(valueComparator);
    }

    private static &lt;V&gt; ImmutableSet&lt;V&gt; emptySet(@Nullable Comparator&lt;? super V&gt; valueComparator) {
	return (valueComparator == null) ? ImmutableSet.&lt;V&gt;of() : ImmutableSortedSet.&lt;V&gt;emptySet(valueComparator);
    }

    class Builder&lt;K, V&gt; extends Builder&lt;K, V&gt; {
	/**
	* Returned by get() when a missing key is provided. Also holds the comparator, if any, used for
	* values.
	*/
	private final transient ImmutableSet&lt;V&gt; emptySet;

	/** Adds a key-value mapping to the built multimap if it is not already present. */
	@CanIgnoreReturnValue
	@Override
	public Builder&lt;K, V&gt; put(K key, V value) {
	    super.put(key, value);
	    return this;
	}

	/** Returns a newly-created immutable set multimap. */
	@Override
	public ImmutableSetMultimap&lt;K, V&gt; build() {
	    Collection&lt;Map.Entry&lt;K, Collection&lt;V&gt;&gt;&gt; mapEntries = builderMap.entrySet();
	    if (keyComparator != null) {
		mapEntries = Ordering.from(keyComparator).&lt;K&gt;onKeys().immutableSortedCopy(mapEntries);
	    }
	    return fromMapEntries(mapEntries, valueComparator);
	}

	/**
	* Creates a new builder. The returned builder is equivalent to the builder generated by {@link
	* ImmutableSetMultimap#builder}.
	*/
	public Builder() {
	    super();
	}

    }

}

